// ( 문제 ) 정수 배열을 정렬해서 반환하는 solution()함수 완성하기
// ( 조건 ) 1. 정수 배열의 길이는 2이상 10의 5제곱 이하.
// ( 조건 ) 2. 정수 배열의 각 데이터 값은 -100,000이상 100,000이하 입니다.

// 입력/출력 예시
//  입력 : [1,-5,2,4,3]  출력 : [-5,1,2,3,4]
//  입력 : [2,1,1,3,2,5,4]  출력 : [1,1,2,2,3,4,5]
//  입력 : [6,1,7]  출력 : [1,6,7]


function solution(arr){
    arr.sort((a,b)=> a-b);
    return arr;
}

console.log("출력1 : " , solution([1,-5,2,4,3]));
console.log("출력2 : " , solution([2,1,1,3,2,5,4]));
console.log("출력3 : " , solution([6,1,7]));


// sort()함수 
// 매개변수는 2개가 필요. 
// 매개변수 a-b를 했을 때, 음수라면 a가 b보다 앞에 위치한다.
//                        양수라면 b가 a보다 앞에 위치한다.
//                        '0'이라면 a와 b의 순서를 변경하지 않는다.
// sort()함수의 배열을 정렬하는 방법은 '삽입정렬','병합정렬','퀵정렬'과 유사하다.


// 1.버블정렬 ---> 시간복잡도 : O(N^2)
// 2.삽입정렬 ---> 시간복잡도 : 최악의 경우 O(N^2)
// 3.병합정렬 ---> 시간복잡도 : O(N log N)
// 4.퀵정렬 ---> 시간복잡도 : 평균 O(N log N), 최악 O(N^2)
// 5.힙정렬 ---> 시간복잡도 : O(N log N)

// => O(N^2) : 데이터크기(N)에 대해 수행하는 작업의 수가 N의 제곱에 비례
//             데이터 크기가 2배가 되면 수행하는 작업은 4배 증가 ( 성능 급락 )
// 데이터 10개 --> 작업 수 10X10 = 100
// 데이터 100ro --> 작업 수 100X100=10000
//           ex) 버블정렬, 삽입정렬


// =>O(N log N) : 데이터크기(N)에대해 작업의 수가 N과 N의 로그의 곱에 비례
//              데이터 크기가 2배가 되면 작업의 수는 약 두배 로그에 비례 증가(안정적)
// 데이터 10개 --> 작업수 10Xlog2(10) = 33.2
// 데이터 100개 --> 작업수 100 X log2(100) = 664
//           ex) 퀵정렬, 병합정렬, 힙정렬


// 결론
// O(N^2) : 큰 데이터에서는 비효율적 ( 성능의 급락 )
// O(N log N) : 데이터 크기가 커져도 성능이 상대적으로 안정적.
// => 데이터크기가 커질 수록 O(N log N)가 O(N^2)보다 효율적.